#include "BDSIQuery.hh"

#include "BDSExecOptions.hh"
#include "BDSFieldFactory.hh"
#include "BDSFieldInfo.hh"
#include "BDSFieldLoader.hh"
#include "BDSGlobalConstants.hh"
#include "BDSParser.hh"

#include "globals.hh"      // geant4 types / globals
#include "G4String.hh"
#include "G4ThreeVector.hh"

#include "parser/query.h"

int main(int argc, char** argv)
{
  /// Print header & program information
  G4cout<<"bdsinterpolator : version @BDSIM_VERSION@"<<G4endl;
  G4cout<<"                  (C) 2001-@CURRENT_YEAR@ Royal Holloway University London"<<G4endl;
  G4cout<<"                  http://www.pp.rhul.ac.uk/bdsim"<<G4endl;
  G4cout<<G4endl;

   /// Initialize executable command line options reader object
  const BDSExecOptions* execOptions = new BDSExecOptions(argc,argv);

  /// Parse lattice file
  auto fileName = execOptions->InputFileName();
  G4cout << __FUNCTION__ << "> Using input file : "<< fileName << G4endl;
  BDSParser::Instance(fileName);

  /// Update options generated by parser with those from executable options.
  BDSParser::Instance()->AmalgamateOptions(execOptions->Options());
  delete execOptions; /// No longer needed.

  /// Force construction of global constants
  BDSGlobalConstants::Instance();

  for (const auto& q : BDSParser::Instance()->GetQuery())
    {
      BDSFieldInfo* recipe = BDSFieldFactory::Instance()->GetDefinition(G4String(q.fieldObject));

      // We don't need to use the full interface of BDSFieldFactory to manufacture a complete
      // geant4 field - we only need the BDSFieldMag* instance.
      BDSFieldMag* field = BDSFieldLoader::Instance()->LoadMagField(*recipe);

      BDSI::Query(field, q);
    }

  delete BDSFieldLoader::Instance();

  return 0;
}
